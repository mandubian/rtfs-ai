# RTFS - Intermediate Representation (IR) Specification (Draft)

This document defines the structure and node types for the canonical Intermediate Representation (IR) of the standalone RTFS language. The IR is the strongly-typed, abstract representation generated by the parser and consumed by type checkers, optimizers, and transpilers/interpreters.

## 1. Goals

*   **Canonical Representation:** Provide a single, unambiguous representation of parsed RTFS code.
*   **Language Independent:** Defined purely based on RTFS semantics, not tied to any source syntax details or target language specifics.
*   **Strongly Typed:** Embed type information directly within the IR nodes, as determined by annotations or type inference. The type can be `:any` for dynamically typed parts.
*   **Analyzable & Transformable:** Structured to facilitate static analysis, type checking, optimization, and code generation.
*   **Serializable:** Should be easily serializable/deserializable (e.g., using formats like EDN, JSON, or binary representations).

## 2. General Structure

The IR is a tree structure composed of nodes. Each node represents a specific language construct (e.g., expression, definition, type, contract).

*   **Node Format:** Each IR node typically includes:
    *   `node-type`: A keyword identifier for the kind of construct (e.g., `:ir/let`, `:ir/if`, `:ir/type-int`).
    *   `type`: The inferred or annotated type of the expression represented by this node (crucial for typed IR). This can be an `:ir/type-*` node or `:any`.
    *   `source-location`: Optional information mapping back to the original source code (line, column) for error reporting.
    *   Specific fields containing child nodes or literal values relevant to the construct.

## 3. Core IR Node Types

*(Note: This list is expanded but may still require further refinement.)*

### 3.1. Top-Level & Task Structure

*   **`:ir/task`**: Represents the entire task artifact.
    *   `node-type`: `:ir/task`
    *   `id`: `:ir/literal` node (with `literal-type` :string).
    *   `metadata`: `:ir/literal` node (with `literal-type` :map, containing `:source`, `:timestamp`, etc.).
    *   `intent`: Expression node (typically `:ir/literal` with `literal-type` :map).
    *   `contracts`: `:ir/contracts` node.
    *   `plan`: Expression node (e.g., `:ir/do`).
    *   `execution-trace`: `:ir/literal` node (with `literal-type` :vector, containing `:ir/log-entry` nodes).
    *   `type`: The type of the task itself (e.g., a specific Task record type).
    *   `source-location`: Optional.

*   **`:ir/contracts`**: Holds contract information.
    *   `node-type`: `:ir/contracts`
    *   `input-schema`: `:ir/schema` node.
    *   `output-schema`: `:ir/schema` node.
    *   `capabilities-required`: `:ir/literal` node (with `literal-type` :vector, containing `:ir/capability-requirement` nodes).
    *   `type`: Type representing the contracts structure.
    *   `source-location`: Optional.

*   **`:ir/log-entry`**: Represents an entry in the execution trace.
    *   `node-type`: `:ir/log-entry`
    *   `timestamp`: `:ir/literal` node (e.g., with `literal-type` :string or :int).
    *   `agent`: `:ir/literal` node (e.g., with `literal-type` :string).
    *   `event`: `:ir/literal` node (e.g., with `literal-type` :keyword).
    *   `details`: Expression node (typically `:ir/literal` with `literal-type` :map).
    *   `previous-entry-hash`: Optional `:ir/literal` node (e.g., with `literal-type` :string).
    *   `signature`: `:ir/signature` node.
    *   `type`: Type representing the log entry structure.
    *   `source-location`: Optional.

*   **`:ir/signature`**: Represents signature details.
    *   `node-type`: `:ir/signature`
    *   `key-id`: `:ir/literal` node (e.g., with `literal-type` :string).
    *   `algo`: `:ir/literal` node (e.g., with `literal-type` :keyword).
    *   `value`: `:ir/literal` node (e.g., with `literal-type` :string).
    *   `type`: Type representing the signature structure.
    *   `source-location`: Optional.

*   **`:ir/capability-requirement`**: Represents a required capability.
    *   `node-type`: `:ir/capability-requirement`
    *   `capability-type`: `:ir/literal` node (with `literal-type` :keyword, e.g., `:tool-call`, `:resource-access`).
    *   `identifier`: `:ir/literal` node (with `literal-type` :map, specifying the target, e.g., `{ :tool-name "tool:fetch-url:v1" }`).
    *   `permissions`: Optional `:ir/literal` node (with `literal-type` :vector of keyword literals, e.g., `[:read :write]`).
    *   `constraints`: Optional `:ir/literal` node (with `literal-type` :map where keys are constraint keywords (e.g., `:path`, `:port`) and values are `:ir/schema-predicate` nodes defining the constraint).
    *   `type`: Type representing the capability structure.
    *   `source-location`: Optional.

### 3.2. Expressions

*   **`:ir/literal`**: Generic node for literal values.
    *   `node-type`: `:ir/literal`
    *   `value`: The actual literal value (e.g., `10`, `"hello"`, `true`, `:kw`, `sym`, `[1 2]`, `{ :a 1 }`).
    *   `literal-type`: The specific literal type keyword (e.g., `:int`, `:float`, `:string`, `:bool`, `:nil`, `:keyword`, `:symbol`, `:vector`, `:map`).
    *   `type`: The corresponding type node (e.g., `:ir/type-int`, `:ir/type-vector`). For collection literals, this type node contains details about element types.
    *   `source-location`: Optional.
    *   *(Note: Replaces previous `:ir/literal-*`, `:ir/literal-vector`, `:ir/literal-map`)*

*   **`:ir/variable-lookup`**: Represents accessing a variable.
    *   `node-type`: `:ir/variable-lookup`
    *   `name`: String (variable name).
    *   `type`: Inferred/resolved type of the variable.
    *   `scope-info`: Optional info linking to the definition site.
    *   `source-location`: Optional.

*   **`:ir/task-context-access`**: Accessing task fields like `@intent`.
    *   `node-type`: `:ir/task-context-access`
    *   `field-name`: Keyword (e.g., `:intent`, `:id`).
    *   `type`: Type of the accessed field.
    *   `source-location`: Optional.

*   **`:ir/if`**: Conditional expression.
    *   `node-type`: `:ir/if`
    *   `condition`: Expression node (must have type :bool or compatible).
    *   `then-branch`: Expression node.
    *   `else-branch`: Expression node.
    *   `type`: The common supertype of the then/else branches.
    *   `source-location`: Optional.

*   **`:ir/do`**: Sequential execution.
    *   `node-type`: `:ir/do`
    *   `expressions`: List of expression nodes.
    *   `type`: Type of the last expression.
    *   `source-location`: Optional.

*   **`:ir/fn`**: Lambda/anonymous function definition.
    *   `node-type`: `:ir/fn`
    *   `params`: List of `[:ir/param ...]` nodes.
    *   `return-type-annotation`: Optional `:ir/type` node.
    *   `body`: List of expression nodes.
    *   `captured-environment`: Optional info about captured lexical variables.
    *   `type`: Function type `[:ir/type-fn ...]`.
    *   `source-location`: Optional.

*   **`:ir/binding-pattern`**: Abstract type for binding patterns. Concrete types below.

*   **`:ir/variable-binding`**: Simple variable binding pattern.
    *   `node-type`: `:ir/variable-binding`
    *   `name`: String (variable name).
    *   `source-location`: Optional.

*   **`:ir/map-destructuring-pattern`**: Map destructuring pattern.
    *   `node-type`: `:ir/map-destructuring-pattern`
    *   `key-bindings`: List of `:ir/map-key-binding` nodes.
    *   `defaults`: Map from String (variable name) to `:ir/literal` node (default value).
    *   `bind-rest-to`: Optional String (variable name for `&`).
    *   `bind-whole-to`: Optional String (variable name for `:as`).
    *   `source-location`: Optional.

*   **`:ir/map-key-binding`**: Represents a key binding within map destructuring.
    *   `node-type`: `:ir/map-key-binding`
    *   `key`: `:ir/literal` node (keyword or string).
    *   `target-pattern`: `:ir/binding-pattern` node (what to bind the value to).
    *   `is-keys-shorthand`: Boolean (true if this came from `:keys [...]`).
    *   `source-location`: Optional.

*   **`:ir/vector-destructuring-pattern`**: Vector destructuring pattern.
    *   `node-type`: `:ir/vector-destructuring-pattern`
    *   `element-patterns`: List of `:ir/binding-pattern` or `:ir/ignore-pattern` nodes.
    *   `bind-rest-to`: Optional String (variable name for `&`).
    *   `bind-whole-to`: Optional String (variable name for `:as`).
    *   `source-location`: Optional.

*   **`:ir/ignore-pattern`**: Represents the `_` ignore pattern.
    *   `node-type`: `:ir/ignore-pattern`
    *   `source-location`: Optional.

*   **`:ir/let`**: Let binding expression.
    *   `node-type`: `:ir/let`
    *   `bindings`: List of `:ir/let-binding` nodes.
    *   `body`: List of IR nodes representing the body expressions.
    *   `type`: Type of the last expression in the body.
    *   `source-location`: Optional.

*   **`:ir/let-binding`**: Single binding within a `let`.
    *   `node-type`: `:ir/let-binding`
    *   `pattern`: `:ir/binding-pattern` node.
    *   `type-annotation`: Optional `:ir/type` node.
    *   `init-expr`: IR node for the expression providing the value.
    *   `type`: Inferred/resolved type of the variable(s) bound by the pattern.
    *   `source-location`: Optional.

*   **`:ir/param`**: Function parameter.
    *   `node-type`: `:ir/param`
    *   `binding`: `:ir/binding-pattern` node (variable or destructuring pattern).
    *   `type-annotation`: Optional `:ir/type` node.
    *   `type`: Resolved type of the parameter(s) bound by the pattern.
    *   `source-location`: Optional.

*   **`:ir/apply`**: Function/tool application.
    *   `node-type`: `:ir/apply`
    *   `function`: Expression node (must evaluate to a function type or tool).
    *   `arguments`: List of expression nodes.
    *   `type`: Return type derived from the function's type signature.
    *   `is-tool-call`: Boolean flag indicating if it's a tool call.
    *   `source-location`: Optional.

*   **`:ir/parallel`**: Parallel execution block.
    *   `node-type`: `:ir/parallel`
    *   `bindings`: List of `[:ir/parallel-binding ...]` nodes.
    *   `type`: Map type `[:ir/type-map ...]` representing the combined results.
    *   `source-location`: Optional.

*   **`:ir/parallel-binding`**: A single binding in a parallel block.
    *   `node-type`: `:ir/parallel-binding`
    *   `id`: String (result identifier, becomes keyword in result map).
    *   `type-annotation`: Optional `:ir/type` node.
    *   `expression`: Expression node to run in parallel.
    *   `type`: Type of the expression.
    *   `source-location`: Optional.

*   **`:ir/with-resource`**: Scoped resource management.
    *   `node-type`: `:ir/with-resource`
    *   `binding-name`: String.
    *   `resource-type-annotation`: `:ir/type` node (the expected resource handle type).
    *   `init-expr`: Expression node that yields the resource handle.
    *   `body`: List of expression nodes.
    *   `type`: Type of the last expression in the body.
    *   `source-location`: Optional.

*   **`:ir/try-catch`**: Error handling block.
    *   `node-type`: `:ir/try-catch`
    *   `try-body`: List of expression nodes.
    *   `catch-clauses`: List of `:ir/catch-clause` nodes.
    *   `type`: Common supertype of the try-body's last expression and all catch bodies.
    *   `source-location`: Optional.

*   **`:ir/catch-clause`**: A single catch block.
    *   `node-type`: `:ir/catch-clause`
    *   `error-type`: `:ir/type` node or keyword (e.g., `:any`) specifying the error type/structure to catch.
    *   `binding-name`: String for the caught error object.
    *   `body`: List of expression nodes.
    *   `type`: Type of the last expression in the body.
    *   `source-location`: Optional.

*   **`:ir/match`**: Pattern matching expression.
    *   `node-type`: `:ir/match`
    *   `expression`: The expression whose value is matched.
    *   `clauses`: List of `:ir/match-clause` nodes.
    *   `type`: Common supertype of all clause bodies.
    *   `source-location`: Optional.

*   **`:ir/match-clause`**: A single clause in a match expression.
    *   `node-type`: `:ir/match-clause`
    *   `pattern`: An `:ir/pattern-*` node.
    *   `guard`: Optional expression node (must evaluate to boolean).
    *   `body`: List of expression nodes.
    *   `type`: Type of the last expression in the body.
    *   `source-location`: Optional.

*   **`:ir/log-step`**: Logging wrapper.
    *   `node-type`: `:ir/log-step`
    *   `step-id`: `:ir/literal` node (with `literal-type` :string).
    *   `expression`: The expression being logged.
    *   `type`: The type of the wrapped expression.
    *   `source-location`: Optional.

### 3.3. Patterns (for `match`)

*   **`:ir/pattern-literal`**: Matches a specific literal value.
    *   `node-type`: `:ir/pattern-literal`
    *   `value`: The literal value to match (actual value, not an IR node).
    *   `literal-type`: The specific literal type keyword (e.g., `:int`, `:float`, `:string`, `:bool`, `:nil`, `:keyword`, `:symbol`).
    *   `source-location`: Optional.
    *   *(Note: Replaces previous `:ir/pattern-literal-*`)*

*   **`:ir/pattern-variable`**: Binds the matched value to a variable.
    *   `node-type`: `:ir/pattern-variable`
    *   `name`: String (variable name).
    *   `type`: Type inferred for the bound variable in the clause body.
    *   `source-location`: Optional.

*   **`:ir/pattern-wildcard`**: Matches anything without binding (`_`).
    *   `node-type`: `:ir/pattern-wildcard`
    *   `source-location`: Optional.

*   **`:ir/pattern-vector`**: Matches a vector structure.
    *   `node-type`: `:ir/pattern-vector`
    *   `elements`: List of `:ir/pattern-*` nodes.
    *   `rest-binding`: Optional string (for `& rest` binding).
    *   `source-location`: Optional.

*   **`:ir/pattern-map`**: Matches a map structure.
    *   `node-type`: `:ir/pattern-map`
    *   `entries`: List of `[key-literal, :ir/pattern-*]` pairs. Keys are `:ir/literal` nodes.
    *   `rest-binding`: Optional string (for `& rest` binding).
    *   `source-location`: Optional.

*   **`:ir/pattern-type`**: Matches based on type (less common in structural typing, maybe for tagged unions).
    *   `node-type`: `:ir/pattern-type`
    *   `type-to-match`: `:ir/type` node.
    *   `source-location`: Optional.

### 3.4. Types & Schemas

*   **`:ir/type-*`**: Nodes representing types themselves.
    *   `node-type`: e.g., `:ir/type-int`, `:ir/type-float`, `:ir/type-string`, `:ir/type-bool`, `:ir/type-nil`, `:ir/type-keyword`, `:ir/type-symbol`, `:ir/type-any`, `:ir/type-never`.
    *   `source-location`: Optional.

*   **`:ir/type-vector`**: Vector type.
    *   `node-type`: `:ir/type-vector`
    *   `element-type`: `:ir/type` node.
    *   `shape`: Optional list containing a single dimension (`:ir/literal` node with `literal-type` :int, or a special marker like `:ir/unknown-dimension`). If absent, size is unknown/unchecked.
    *   `source-location`: Optional.

*   **`:ir/type-array`**: Multi-dimensional array/tensor type.
    *   `node-type`: `:ir/type-array`
    *   `element-type`: `:ir/type` node.
    *   `shape`: List of dimensions (`:ir/literal` node with `literal-type` :int, or a special marker like `:ir/unknown-dimension`).
    *   `source-location`: Optional.

*   **`:ir/unknown-dimension`**: Represents an unknown dimension (`?`) in a shape.
    *   `node-type`: `:ir/unknown-dimension`
    *   `source-location`: Optional.

*   **`:ir/type-list`**: List type (distinct from vector if needed).
    *   `node-type`: `:ir/type-list`
    *   `element-type`: `:ir/type` node.
    *   `source-location`: Optional.

*   **`:ir/type-tuple`**: Tuple type.
    *   `node-type`: `:ir/type-tuple`
    *   `element-types`: List of `:ir/type` nodes.
    *   `source-location`: Optional.

*   **`:ir/type-map`**: Map type.
    *   `node-type`: `:ir/type-map`
    *   `entries`: List of `[:ir/map-type-entry ...]` nodes.
    *   `is-open`: Boolean (allows extra keys if true, corresponds to `[:* :any]` in syntax).
    *   `source-location`: Optional.

*   **`:ir/map-type-entry`**: Entry in a map type definition.
    *   `node-type`: `:ir/map-type-entry`
    *   `key`: `:ir/literal` node (with `literal-type` :keyword). (**Enforced**: Keys in type definitions must be keywords).
    *   `value-type`: `:ir/type` node.
    *   `is-optional`: Boolean.
    *   `source-location`: Optional.

*   **`:ir/type-union`**: Union type (`:or`).
    *   `node-type`: `:ir/type-union`
    *   `types`: List of `:ir/type` nodes.
    *   `source-location`: Optional.

*   **`:ir/type-intersection`**: Intersection type (`:and`).
    *   `node-type`: `:ir/type-intersection`
    *   `base-type`: `:ir/type` node.
    *   `predicates`: List of `:ir/schema-predicate` nodes.
    *   `source-location`: Optional.

*   **`:ir/type-fn`**: Function type (`:=>`).
    *   `node-type`: `:ir/type-fn`
    *   `param-types`: List of `:ir/type` nodes.
    *   `variadic-param-type`: Optional `:ir/type` node (for `[:* T]`).
    *   `return-type`: `:ir/type` node.
    *   `source-location`: Optional.

*   **`:ir/type-resource`**: Resource handle type.
    *   `node-type`: `:ir/type-resource`
    *   `name`: String (e.g., "FileHandle", "TensorHandle").
    *   `source-location`: Optional.

*   **`:ir/schema`**: Represents a schema definition (used in contracts).
    *   `node-type`: `:ir/schema`
    *   `schema-type`: The `:ir/type-*` node defining the schema structure.
    *   `source-location`: Optional.

*   **`:ir/schema-predicate`**: Represents a predicate within a schema (`:and`) or capability constraint.
    *   `node-type`: `:ir/schema-predicate`
    *   `predicate-name`: `:ir/literal` node (with `literal-type` :keyword or :symbol, e.g., `:>`, `:string-starts-with`).
    *   `arguments`: List of `:ir/literal` nodes (e.g., `[0]`, `["http://"]`).
    *   `type`: Boolean (implicitly).
    *   `source-location`: Optional.

### 3.5. Module System (Conceptual)

*   **`:ir/module`**: Represents a module definition.
    *   `node-type`: `:ir/module`
    *   `name`: String or symbol (module name).
    *   `imports`: List of `:ir/import` nodes.
    *   `definitions`: List of definition nodes (e.g., `:ir/def`, `:ir/defn`).
    *   `exports`: List of `:ir/export` nodes.
    *   `source-location`: Optional.

*   **`:ir/def` / `:ir/defn`**: Top-level definitions within a module.
    *   Similar to `:ir/let-binding` or `:ir/fn` but representing top-level definitions.
    *   Includes visibility info (public/private based on exports).

*   **`:ir/import`**: Represents an import statement.
    *   `node-type`: `:ir/import`
    *   `module-name`: String or symbol.
    *   `alias`: Optional string/symbol.
    *   `only`: Optional list of symbols to import.
    *   `refer-all`: Boolean.
    *   `source-location`: Optional.

*   **`:ir/export`**: Represents an export statement.
    *   `node-type`: `:ir/export`
    *   `symbol-name`: String or symbol being exported.
    *   `source-location`: Optional.

## 4. Processing Pipeline

1.  **Parsing:** Source Text (e.g., `.rtfs` file) -> Raw Syntax Tree (Untyped, syntax-focused, potentially using S-expression structure).
2.  **IR Generation & Validation:** Raw Syntax Tree -> Typed IR (this specification). This phase involves:
    *   Resolving variable scopes and linking lookups to definitions.
    *   Performing type checking based on annotations and inference rules (populating the `type` field in each node).
    *   Validating contracts (`:input-schema`, `:output-schema`) against plan structure and types.
    *   Validating `:capabilities-required` against tool calls present in the plan.
    *   Resolving tool signatures (requires external mechanism, see `language_semantics.md`).
    *   Transforming syntax into canonical IR nodes.
    *   Reporting static errors (type errors, scope errors, contract violations).
3.  **Optimization (Optional):** Typed IR -> Optimized Typed IR (e.g., constant folding, dead code elimination).
4.  **Code Generation/Interpretation:** Typed IR -> Target Code (e.g., Clojure, Rust, Python bytecode) or Direct Execution by an RTFS runtime.

This typed IR serves as the crucial, verified intermediate step before execution or transpilation, capturing the full semantics and type information of the RTFS program.
